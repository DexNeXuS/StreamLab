/**
 * 1. Rename emote images to {folderName}_{size}.png (e.g. dexzz_28.png).
 *    Current names like emote_5-Photoroom@28.png → size is the number after @.
 * 2. Generate assets/data/emotes.json with one entry per folder (id, name, description, sizes).
 *    Run from Streaming/: node tools/build-emotes.mjs
 */

import { readdir, rename, writeFile, readFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, "..");
const EMOTES_DIR = path.join(ROOT, "assets", "images", "page-images", "emotes");
const OUT_JSON = path.join(ROOT, "assets", "data", "emotes.json");

// Match size in filename: ...@18.png, @28.png, etc.
const SIZE_REGEX = /@(\d+)\.png$/i;

function capitalizeId(id) {
  return id.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
}

async function main() {
  const dirs = await readdir(EMOTES_DIR, { withFileTypes: true });
  const folders = dirs.filter((d) => d.isDirectory()).map((d) => d.name);
  const sets = [];

  for (const folderName of folders) {
    const folderPath = path.join(EMOTES_DIR, folderName);
    const files = await readdir(folderPath);
    const pngFiles = files.filter((f) => f.toLowerCase().endsWith(".png"));
    const sizes = [];

    for (const file of pngFiles) {
      const m = file.match(SIZE_REGEX);
      const size = m ? m[1] : null;
      if (!size) continue;
      const newName = `${folderName}_${size}.png`;
      const oldPath = path.join(folderPath, file);
      const newPath = path.join(folderPath, newName);
      if (file !== newName) {
        await rename(oldPath, newPath);
        console.log(`  ${folderName}/${file} → ${newName}`);
      }
      if (!sizes.includes(size)) sizes.push(size);
    }

    sizes.sort((a, b) => Number(a) - Number(b));
    sets.push({
      id: folderName,
      name: capitalizeId(folderName),
      description: "",
      sizes: sizes,
    });
  }

  // Preserve existing name/description if emotes.json already exists
  let existing = { sets: [] };
  try {
    const raw = await readFile(OUT_JSON, "utf8");
    existing = JSON.parse(raw);
  } catch {
    // no existing file
  }

  const existingById = new Map((existing.sets || []).map((s) => [s.id, s]));
  const merged = sets.map((s) => {
    const prev = existingById.get(s.id);
    return {
      id: s.id,
      name: (prev && prev.name) || s.name,
      description: (prev && prev.description) || s.description,
      sizes: s.sizes,
    };
  });

  await writeFile(
    OUT_JSON,
    JSON.stringify({ description: "Emote sets; add name/description per set. Generated by tools/build-emotes.mjs.", sets: merged }, null, 2) + "\n",
    "utf8"
  );
  console.log(`Wrote ${OUT_JSON} (${merged.length} sets)`);
}

main().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
